-- Enable the CITEXT extension for case-insensitive email handling
CREATE EXTENSION IF NOT EXISTS citext;

-------------------------------------------------------------
-- 1) Drop all dependent tables in the proper order
-------------------------------------------------------------
DROP TABLE IF EXISTS usage_records;
DROP TABLE IF EXISTS feature_requests;
DROP TABLE IF EXISTS features;
DROP TABLE IF EXISTS credit_transactions;
DROP TABLE IF EXISTS payments;
DROP TABLE IF EXISTS subscriptions;
DROP TABLE IF EXISTS translations;
DROP TABLE IF EXISTS project_channel;
DROP TABLE IF EXISTS user_details;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS roles;
DROP TABLE IF EXISTS statuses;
DROP TABLE IF EXISTS queue;

-------------------------------------------------------------
-- 2) Re-Create roles table (with updated_at) and insert rows
-------------------------------------------------------------
CREATE TABLE roles (
                       role_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                       name VARCHAR(50) NOT NULL,
                       description TEXT,
                       created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                       updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Insert the specified roles, overriding the identity so that role_id = 0..3
INSERT INTO roles (role_id, name, description)
    OVERRIDING SYSTEM VALUE
VALUES
    (0, 'Noob',    'Default, minimum permissions'),
    (1, 'Founder', 'Like Superadmin'),
    (2, 'Alpha',   'Alpha tester'),
    (3, 'Beta',    'Beta tester');

-------------------------------------------------------------
-- 3) Create the other tables
-------------------------------------------------------------
-- Users table with soft delete (deleted_at column)
CREATE TABLE users (
                       user_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                       email CITEXT NOT NULL UNIQUE,
                       role_id INTEGER NOT NULL,
                       current_credit INTEGER DEFAULT 0,
                       created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                       updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                       deleted_at TIMESTAMP NULL,
                       FOREIGN KEY (role_id) REFERENCES roles(role_id)
);
CREATE INDEX idx_users_role_id ON users(role_id);

-- user_details table (one-to-one relationship with users)
CREATE TABLE user_details (
                              user_detail_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                              user_id INTEGER UNIQUE NOT NULL,
                              first_name VARCHAR(100),
                              last_name VARCHAR(100),
                              phone VARCHAR(50),
                              address TEXT,
                              created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                              updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                              FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- project_channel table
CREATE TABLE project_channel (
                                 channel_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                 user_id INTEGER NOT NULL,
                                 channel_name VARCHAR(255) NOT NULL,
                                 created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                 updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                 FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE INDEX idx_project_channel_user_id ON project_channel(user_id);

-- translations table with URL columns for asset references
CREATE TABLE translations (
                              translation_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                              user_id INTEGER NOT NULL,
                              target_channel_id INTEGER NOT NULL,
                              source_channel VARCHAR(255),
                              original_asset_url TEXT,   -- URL to the original asset
                              translated_asset_url TEXT, -- URL to the translated asset
                              created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                              updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                              FOREIGN KEY (user_id) REFERENCES users(user_id),
                              FOREIGN KEY (target_channel_id) REFERENCES project_channel(channel_id)
);
CREATE INDEX idx_translations_user_id ON translations(user_id);
CREATE INDEX idx_translations_target_channel_id ON translations(target_channel_id);

-- subscriptions table
CREATE TABLE subscriptions (
                               subscription_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                               user_id INTEGER NOT NULL,
                               plan VARCHAR(100) NOT NULL,
                               status VARCHAR(50) NOT NULL,
                               start_date DATE,
                               end_date DATE,
                               created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                               updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                               FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);

-- payments table
CREATE TABLE payments (
                          payment_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          user_id INTEGER NOT NULL,
                          stripe_payment_id VARCHAR(255) NOT NULL,
                          amount NUMERIC(10,2) NOT NULL,
                          currency VARCHAR(10) NOT NULL,
                          payment_date TIMESTAMP NOT NULL,
                          created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                          updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                          FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE INDEX idx_payments_user_id ON payments(user_id);

-- credit_transactions table (immutable/append-only)
CREATE TABLE credit_transactions (
                                     transaction_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                     user_id INTEGER NOT NULL,
                                     credit_change INTEGER NOT NULL,
                                     new_credit INTEGER NOT NULL,
                                     action TEXT,
                                     created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                     FOREIGN KEY (user_id) REFERENCES users(user_id)
);
CREATE INDEX idx_credit_transactions_user_id ON credit_transactions(user_id);

-------------------------------------------------------------
-- 3A) Create new tables for feature requests and usage records
-------------------------------------------------------------
-- Features table: list of features, e.g., Translation, StoryGeneration, etc.
CREATE TABLE features (
                          feature_id SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          name VARCHAR(100) NOT NULL,
                          description TEXT,
                          created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                          updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Feature Requests table (append-only): stores each request with a configuration in JSONB.
CREATE TABLE feature_requests (
                                  request_id SERIAL PRIMARY KEY,
                                  feature_id SMALLINT NOT NULL,
                                  configuration JSONB NOT NULL,
                                  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                                  FOREIGN KEY (feature_id) REFERENCES features(feature_id)
);
-- This table is read/append only; no UPDATE/DELETE allowed.

-- Usage Records table (append-only): stores detailed token usage per model for each request.
CREATE TABLE usage_records (
                               request_id INTEGER NOT NULL,
                               model VARCHAR(50) NOT NULL,
                               prompt_tokens INTEGER NOT NULL,
                               completion_tokens INTEGER NOT NULL,
                               cached_tokens INTEGER NOT NULL,
                               reasoning_tokens INTEGER NOT NULL,
    -- Example of a computed (generated) column:
    -- Generated columns (or computed columns) in PostgreSQL calculate their value based on other columns.
    -- Here, total_tokens is automatically computed as the sum of the token fields.
    -- total_tokens INTEGER GENERATED ALWAYS AS (prompt_tokens + completion_tokens + cached_tokens + reasoning_tokens) STORED,
                               created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                               PRIMARY KEY (request_id, model),
                               FOREIGN KEY (request_id) REFERENCES feature_requests(request_id) ON DELETE CASCADE
);
-- This table is also read/append only.

-------------------------------------------------------------
-- 3B) Create new tables for queue status
-------------------------------------------------------------
CREATE TABLE statuses (
                          status_id SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          name VARCHAR(50) NOT NULL,
                          description TEXT
);

-- Minimal statuses
INSERT INTO statuses (status_id, name, description)
    OVERRIDING SYSTEM VALUE
VALUES
    (1, 'pending',    'Awaiting processing'),
    (2, 'processing', 'Job is being processed'),
    (3, 'done',       'Job completed successfully'),
    (4, 'error',      'An error occurred');

-------------------------------------------------------------
-- 3C) Create new tables for queue status
-------------------------------------------------------------
CREATE TABLE queue (
                       queue_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                       user_id INTEGER NOT NULL,            -- references users(user_id)
                       feature_id SMALLINT NOT NULL,        -- references features(feature_id)
                       request JSONB NOT NULL,              -- extra config/payload
                       priority INTEGER NOT NULL,           -- e.g. 1=High, 2=Medium, 3=Low
                       status_id SMALLINT NOT NULL,          -- references statuses(status_id)
                       retries INTEGER NOT NULL DEFAULT 0,  -- number of times we retried
                       created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                       updated_at TIMESTAMPTZ NOT NULL,
                       FOREIGN KEY (user_id) REFERENCES users(user_id),
                       FOREIGN KEY (feature_id) REFERENCES features(feature_id),
                       FOREIGN KEY (status_id) REFERENCES statuses(status_id)
);

-------------------------------------------------------------
-- 3D) Create new tables for queue config
-------------------------------------------------------------
CREATE TABLE feature_queue_config (
                                      queue_type_id        SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                      queue_type_name VARCHAR(50),
                                      paused           BOOLEAN NOT NULL DEFAULT false,
                                      force_cancel     BOOLEAN NOT NULL DEFAULT false,
                                      max_slots_high   INT NOT NULL DEFAULT 10,
                                      max_slots_medium INT NOT NULL DEFAULT 5,
                                      max_slots_low    INT NOT NULL DEFAULT 3
);

-------------------------------------------------------------
-- 4) Create the updated_at trigger function
-------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------
-- 5) Create triggers for all tables that have updated_at
-------------------------------------------------------------
-- roles
CREATE TRIGGER update_roles_updated_at
    BEFORE UPDATE ON roles
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- users
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- user_details
CREATE TRIGGER update_user_details_updated_at
    BEFORE UPDATE ON user_details
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- project_channel
CREATE TRIGGER update_project_channel_updated_at
    BEFORE UPDATE ON project_channel
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- translations
CREATE TRIGGER update_translations_updated_at
    BEFORE UPDATE ON translations
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- subscriptions
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- payments
CREATE TRIGGER update_payments_updated_at
    BEFORE UPDATE ON payments
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- features
CREATE TRIGGER update_features_updated_at
    BEFORE UPDATE ON features
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- updated_at trigger for queue
CREATE TRIGGER update_queue_updated_at
    BEFORE UPDATE ON queue
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-------------------------------------------------------------
-- 6) Enforce immutability on credit_transactions (prevent UPDATE/DELETE)
-------------------------------------------------------------
CREATE OR REPLACE FUNCTION prevent_credit_transactions_modification()
    RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Immutable table: credit_transactions cannot be modified.';
RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_credit_transactions_update
    BEFORE UPDATE OR DELETE ON credit_transactions
    FOR EACH ROW
EXECUTE PROCEDURE prevent_credit_transactions_modification();

-------------------------------------------------------------
-- 7) Enforce immutability on feature_requests and usage_records (append-only)
-------------------------------------------------------------
CREATE OR REPLACE FUNCTION prevent_feature_requests_modification()
    RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Immutable table: feature_requests cannot be modified.';
RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_feature_requests_update
    BEFORE UPDATE OR DELETE ON feature_requests
    FOR EACH ROW
EXECUTE PROCEDURE prevent_feature_requests_modification();

CREATE OR REPLACE FUNCTION prevent_usage_records_modification()
    RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Immutable table: usage_records cannot be modified.';
RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_usage_records_update
    BEFORE UPDATE OR DELETE ON usage_records
    FOR EACH ROW
EXECUTE PROCEDURE prevent_usage_records_modification();

-------------------------------------------------------------
-- 8) Enforce credit transaction consistency (prevent negative balances)
-------------------------------------------------------------
-- BEFORE INSERT: Set new_credit and prevent negative balances
CREATE OR REPLACE FUNCTION set_credit_transaction_new_credit()
    RETURNS TRIGGER AS $$
DECLARE
curr_credit INTEGER;
    computed_credit INTEGER;
BEGIN
    -- Lock the user row for the most recent current_credit
SELECT current_credit INTO curr_credit
FROM users
WHERE user_id = NEW.user_id
    FOR UPDATE;

computed_credit := curr_credit + NEW.credit_change;

    IF computed_credit < 0 THEN
        RAISE EXCEPTION 'Insufficient credits: current_credit = %, credit_change = %, resulting in negative balance.', curr_credit, NEW.credit_change;
END IF;

    NEW.new_credit := computed_credit;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_credit_transaction_insert
    BEFORE INSERT ON credit_transactions
    FOR EACH ROW
    EXECUTE PROCEDURE set_credit_transaction_new_credit();

-- AFTER INSERT: Update user's current_credit to the new balance
CREATE OR REPLACE FUNCTION update_user_credit_on_transaction()
    RETURNS TRIGGER AS $$
BEGIN
UPDATE users
SET current_credit = NEW.new_credit,
    updated_at = NOW()
WHERE user_id = NEW.user_id;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_credit_transaction_insert
    AFTER INSERT ON credit_transactions
    FOR EACH ROW
    EXECUTE PROCEDURE update_user_credit_on_transaction();



---------------------------------------------------------------
-- Create a table for asset types (for video_assets.asset_type)
---------------------------------------------------------------
CREATE TABLE asset_types (
                             asset_type_id SMALLINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                             name VARCHAR(50) NOT NULL,
                             description TEXT
);

-- Insert common asset types
INSERT INTO asset_types (name, description)
VALUES
    ('script', 'The video script'),
    ('voiceover', 'The generated voiceover audio'),
    ('thumbnail', 'The video thumbnail image'),
    ('broll', 'Supplementary video clips'),
    ('final_video', 'The final assembled video');

---------------------------------------------------------------
-- 1. Videos table representing an overall video project.
---------------------------------------------------------------
CREATE TABLE videos (
                        video_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                        channel_id INTEGER NOT NULL REFERENCES project_channel(channel_id),
                        title VARCHAR(255) NOT NULL,
                        description TEXT,
                        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Trigger to update the updated_at column for videos.
CREATE TRIGGER update_videos_updated_at
    BEFORE UPDATE ON videos
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

---------------------------------------------------------------
-- 2. Video Assets table (hybrid approach)
-- Common fields: asset_url, display_order, duration (INTERVAL)
-- Variable configuration: asset_config (JSONB)
---------------------------------------------------------------
CREATE TABLE video_assets (
                              asset_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                              video_id INTEGER NOT NULL REFERENCES videos(video_id),
                              asset_type_id SMALLINT NOT NULL, -- references asset_types
                              asset_url TEXT,                  -- common URL or file location
                              display_order INTEGER,           -- ordering of assets within a video
                              duration INTERVAL,               -- duration (hours, minutes, seconds, milliseconds)
                              asset_config JSONB DEFAULT '{}'::jsonb,  -- dynamic/asset-specific configuration
                              created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                              updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                              FOREIGN KEY (asset_type_id) REFERENCES asset_types(asset_type_id)
);

-- Trigger to update the updated_at column for video_assets.
CREATE TRIGGER update_video_assets_updated_at
    BEFORE UPDATE ON video_assets
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

---------------------------------------------------------------
-- 3. Dependency table for video assets (without ON DELETE CASCADE)
---------------------------------------------------------------
CREATE TABLE video_asset_dependencies (
                                          asset_id INTEGER NOT NULL,           -- asset that is waiting on dependencies
                                          dependency_asset_id INTEGER NOT NULL,  -- asset that must be completed first
                                          PRIMARY KEY (asset_id, dependency_asset_id),
                                          FOREIGN KEY (asset_id) REFERENCES video_assets(asset_id),
                                          FOREIGN KEY (dependency_asset_id) REFERENCES video_assets(asset_id)
);

---------------------------------------------------------------
-- 4. Update the queue table to link each task to a video and a specific asset.
---------------------------------------------------------------
ALTER TABLE queue
    ADD COLUMN video_id INTEGER,
    ADD COLUMN asset_id INTEGER;

ALTER TABLE queue
    ADD CONSTRAINT fk_queue_video
        FOREIGN KEY (video_id) REFERENCES videos(video_id),
    ADD CONSTRAINT fk_queue_asset
        FOREIGN KEY (asset_id) REFERENCES video_assets(asset_id);


---------------------------------------------------------------
-- File: default_channel_video_setup.sql
-- Purpose: Automatically create a default channel and video
--          for every new user, and backfill defaults for existing users.
--
-- This file contains:
--   1) A trigger function that creates a default channel and video
--      when a new user is inserted.
--   2) A trigger on the users table to invoke that function.
--   3) Backfill INSERT statements to create default channels and videos
--      for users/channels that are missing them.
---------------------------------------------------------------

---------------------------------------------------------------
-- 1. Trigger Function for New Users
---------------------------------------------------------------
-- This function is called after a new user is inserted.
-- It creates a default channel for the user in the project_channel table,
-- and then creates a default video for that channel in the videos table.
---------------------------------------------------------------
CREATE OR REPLACE FUNCTION create_default_channel_and_video()
    RETURNS TRIGGER AS $$
DECLARE
new_channel_id INTEGER;
BEGIN
    -- Insert a default channel for the new user.
INSERT INTO project_channel (user_id, channel_name)
VALUES (NEW.user_id, 'Default Channel')
    RETURNING channel_id INTO new_channel_id;

-- Insert a default video associated with the newly created channel.
INSERT INTO videos (channel_id, title, description)
VALUES (new_channel_id, 'Default Video', 'Automatically created default video');

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

---------------------------------------------------------------
-- 2. Create Trigger on the users table
---------------------------------------------------------------
-- This trigger calls the create_default_channel_and_video() function
-- every time a new user is inserted.
---------------------------------------------------------------
CREATE TRIGGER after_user_insert_create_defaults
    AFTER INSERT ON users
    FOR EACH ROW
    EXECUTE PROCEDURE create_default_channel_and_video();

---------------------------------------------------------------
-- 3. Backfill Default Channels for Existing Users
---------------------------------------------------------------
-- For each user who doesn't have a default channel in project_channel,
-- create one.
---------------------------------------------------------------
INSERT INTO project_channel (user_id, channel_name)
SELECT u.user_id, 'Default Channel for ' || u.email
FROM users u
WHERE NOT EXISTS (
    SELECT 1
    FROM project_channel pc
    WHERE pc.user_id = u.user_id
);

---------------------------------------------------------------
-- 4. Backfill Default Videos for Existing Channels
---------------------------------------------------------------
-- For each channel in project_channel that doesn't have an associated video in videos,
-- create a default video.
---------------------------------------------------------------
INSERT INTO videos (channel_id, title, description)
SELECT pc.channel_id, 'Default Video', 'Automatically created default video'
FROM project_channel pc
WHERE NOT EXISTS (
    SELECT 1
    FROM videos v
    WHERE v.channel_id = pc.channel_id
);

---------------------------------------------------------------
-- End of default_channel_video_setup.sql
---------------------------------------------------------------

---------------------------------------------------------------
-- 1. Alter project_channel table to add is_default column
---------------------------------------------------------------
ALTER TABLE project_channel
    ADD COLUMN is_default BOOLEAN NOT NULL DEFAULT false;

---------------------------------------------------------------
-- 2. Alter videos table to add is_default column
---------------------------------------------------------------
ALTER TABLE videos
    ADD COLUMN is_default BOOLEAN NOT NULL DEFAULT false;

---------------------------------------------------------------
-- 3. Create or Replace Trigger Function for New Users
---------------------------------------------------------------
-- This function creates a default channel and a default video for
-- a new user, and marks them as default by setting is_default = true.
---------------------------------------------------------------
CREATE OR REPLACE FUNCTION create_default_channel_and_video()
    RETURNS TRIGGER AS $$
DECLARE
new_channel_id INTEGER;
BEGIN
    -- Insert a default channel for the new user, marked as default.
INSERT INTO project_channel (user_id, channel_name, is_default)
VALUES (NEW.user_id, 'Default', true)
    RETURNING channel_id INTO new_channel_id;

-- Insert a default video associated with the newly created channel,
-- also marked as default.
INSERT INTO videos (channel_id, title, description, is_default)
VALUES (new_channel_id, 'Default', 'default', true);

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Drop the foreign key constraint referencing videos
ALTER TABLE queue
DROP CONSTRAINT fk_queue_video;

-- Remove the video_id column since it's no longer needed
ALTER TABLE queue
DROP COLUMN video_id;

ALTER TABLE queue
    ADD COLUMN is_dev BOOLEAN NOT NULL DEFAULT FALSE;

ALTER TABLE video_assets
    ADD COLUMN urls JSONB;

-- Create the pricing_rules table (stores rule JSON)
CREATE TABLE pricing_rules (
                               rule_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                               rule_data JSONB NOT NULL,
                               created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                               updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- updated_at trigger for pricing_rules
CREATE TRIGGER update_pricing_rules_updated_at
    BEFORE UPDATE ON pricing_rules
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- Create the feature_rule_mapping table (maps a feature from your features table to a pricing rule)
CREATE TABLE feature_rule_mapping (
                                      feature_id SMALLINT PRIMARY KEY,  -- This uses the same ID as in your features table (EFeature values)
                                      rule_id INTEGER NOT NULL,
                                      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                      updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                      FOREIGN KEY (feature_id) REFERENCES features(feature_id),
                                      FOREIGN KEY (rule_id) REFERENCES pricing_rules(rule_id)
);

-- updated_at trigger for feature_rule_mapping
CREATE TRIGGER update_feature_rule_mapping_updated_at
    BEFORE UPDATE ON feature_rule_mapping
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

----------------------------------------------------------
-- Example Inserts
----------------------------------------------------------
-- Insert a pricing rule for AiStory (feature_id = 1)
INSERT INTO pricing_rules (rule_data)
VALUES (
           '{
             "DurationCosts": [
               { "Duration": 15,  "Cost": 20 },
               { "Duration": 20, "Cost": 25 },
               { "Duration": 25, "Cost": 25 },
               { "Duration": 30, "Cost": 30 },
               { "Duration": 35, "Cost": 30 },
               { "Duration": 40, "Cost": 35 },
               { "Duration": 45, "Cost": 35 },
               { "Duration": 50, "Cost": 40 },
               { "Duration": 55, "Cost": 40 },
               { "Duration": 60, "Cost": 45 }
             ]
           }'::jsonb
       );

-- Insert a pricing rule for Translation (feature_id = 2)
INSERT INTO pricing_rules (rule_data)
VALUES (
           '{
             "BaseUnit": 800,
             "MinimumCharge": 10,
             "Thresholds": [
               { "Limit": 20000, "Multiplier": 1.10 },
               { "Limit": 40000, "Multiplier": 1.20 },
               { "Limit": 60000, "Multiplier": 1.25 },
               { "Limit": 80000, "Multiplier": 1.30 },
               { "Limit": 100000, "Multiplier": 1.35 }
             ]
           }'::jsonb
       );

INSERT INTO pricing_rules (rule_data)
VALUES (
           '{
             "Models": {
               "FalAiFluxDev":{
                 "BaseCost": 20,
                 "MultiplierPerNumberOfImages":{
                   "1": 1,
                   "2": 2,
                   "3": 2.5,
                   "4": 3.5

                 }
               }
             }
           }'::jsonb
       );

-- Map the features to their pricing rules (assuming the first insert gets rule_id = 1 and the second rule_id = 2)
INSERT INTO feature_rule_mapping (feature_id, rule_id)
VALUES (1, 1);

INSERT INTO feature_rule_mapping (feature_id, rule_id)
VALUES (2, 2);

-- This function prevents unauthorized updates to current_credit.
CREATE OR REPLACE FUNCTION enforce_credit_integrity()
    RETURNS TRIGGER AS $$
DECLARE
bypass TEXT;
BEGIN
    -- Try to get a custom setting; if not set, bypass will be NULL.
    bypass := current_setting('myapp.bypass_credit_update', true);
    IF bypass IS DISTINCT FROM 'true' THEN
        IF NEW.current_credit <> OLD.current_credit THEN
            RAISE EXCEPTION 'Direct updates to current_credit are not allowed';
END IF;
END IF;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger on the users table.
CREATE TRIGGER enforce_credit_integrity_trigger
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE PROCEDURE enforce_credit_integrity();

CREATE OR REPLACE FUNCTION update_user_credit_on_transaction()
    RETURNS TRIGGER AS $$
BEGIN
    -- Allow this update by setting the bypass flag for the duration of the transaction.
    PERFORM set_config('myapp.bypass_credit_update', 'true', true);

UPDATE users
SET current_credit = NEW.new_credit,
    updated_at = NOW()
WHERE user_id = NEW.user_id;

RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-------------------------------------------------------------
-- Create new tables for Stripe-related subscription management
-------------------------------------------------------------

-- Create suscriptions table (subscription plans)
CREATE TABLE suscriptions (
                              suscription_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                              name VARCHAR(255) NOT NULL,
                              description TEXT,
                              price NUMERIC(10,2) NOT NULL,
                              active BOOLEAN NOT NULL DEFAULT FALSE,
                              "show_order" INTEGER,  -- Using quotes because ORDER is a reserved word.
                              is_one_time BOOLEAN NOT NULL DEFAULT FALSE,
                              created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                              updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Trigger to update the updated_at column for suscriptions
CREATE TRIGGER update_suscriptions_updated_at
    BEFORE UPDATE ON suscriptions
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-- Create suscription_status table (subscription status options)
CREATE TABLE suscription_status (
                                    suscription_status_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                    name VARCHAR(255) NOT NULL,
                                    description TEXT,
                                    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                                    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Trigger to update the updated_at column for suscription_status
CREATE TRIGGER update_suscription_status_updated_at
    BEFORE UPDATE ON suscription_status
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

-------------------------------------------------------------
-- Alter the users table to add Stripe related fields
-------------------------------------------------------------
ALTER TABLE users
    ADD COLUMN customer_id VARCHAR(255),
    ADD COLUMN suscription_id INTEGER,
    ADD COLUMN suscription_status_id INTEGER;

-- Add foreign key constraints linking to the new tables
ALTER TABLE users
    ADD CONSTRAINT fk_users_suscription FOREIGN KEY (suscription_id)
        REFERENCES suscriptions(suscription_id);

ALTER TABLE users
    ADD CONSTRAINT fk_users_suscription_status FOREIGN KEY (suscription_status_id)
        REFERENCES suscription_status(suscription_status_id);

-- Insert Stripe-like subscription statuses
INSERT INTO suscription_status (name, description)
VALUES
    ('None', 'None.'),
    ('incomplete', 'Subscription is created but lacks a valid payment.'),
    ('incomplete_expired', 'Subscription stayed incomplete and is now expired.'),
    ('trialing', 'Subscription is currently in a trial period.'),
    ('active', 'Subscription is active and fully paid.'),
    ('past_due', 'Subscription payment is late or past due.'),
    ('canceled', 'Subscription has been canceled.'),
    ('unpaid', 'Subscription is unpaid (Stripe cannot process payment).');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time)
VALUES
    ('Tier 0', 'Free', 1.00, TRUE, 0, FALSE),
    ('Tier 1', 'Basic', 1.00, TRUE, 1, FALSE),
    ('Tier 2', 'Advanced', 2.00, TRUE, 2, FALSE),
    ('Tier 3', 'Premium', 4.00, TRUE, 3, FALSE);

SELECT * FROM suscriptions;

SELECT * FROM users;

SELECT * FROM suscription_status;

ALTER TABLE suscriptions
    ADD COLUMN product_id VARCHAR(255);

SELECT * FROM roles;

ALTER TABLE users
    ADD COLUMN banned BOOLEAN NOT NULL DEFAULT FALSE;

-------------------------------------------------------------
-- 1) Create models table
-------------------------------------------------------------
CREATE TABLE models (
                        model_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        description TEXT
);

-------------------------------------------------------------
-- 2) Create voices table
-------------------------------------------------------------
CREATE TABLE voices (
                        voice_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                        language_id INTEGER NOT NULL,
                        model_id INTEGER NOT NULL,
                        language_code VARCHAR(10),
                        voice_language_code VARCHAR(10),
                        voice_name VARCHAR(255),
                        original_voice_name VARCHAR(255),
                        FOREIGN KEY (language_id) REFERENCES languages(id),
                        FOREIGN KEY (model_id) REFERENCES models(model_id)
);

ALTER TABLE voices
    ADD COLUMN url VARCHAR(255);

-- Table for general webhook configuration per user.
CREATE TABLE webhooks (
                          webhook_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          user_id INTEGER NOT NULL,
                          url TEXT NOT NULL,
                          active BOOLEAN NOT NULL DEFAULT TRUE,
                          created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                          FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Intermediate table to map webhooks to features.
CREATE TABLE webhook_features (
                                  webhook_id INTEGER NOT NULL,
                                  feature_id SMALLINT NOT NULL,
                                  PRIMARY KEY (webhook_id, feature_id),
                                  FOREIGN KEY (webhook_id) REFERENCES webhooks(webhook_id) ON DELETE CASCADE,
                                  FOREIGN KEY (feature_id) REFERENCES features(feature_id)
);

CREATE TABLE api_keys (
                          api_key_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          user_id INTEGER NOT NULL,
                          api_key TEXT NOT NULL UNIQUE,
                          name VARCHAR(255) NOT NULL,
                          created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                          FOREIGN KEY (user_id) REFERENCES users(user_id)
);

ALTER TABLE api_keys ADD COLUMN display_key VARCHAR(255);
ALTER TABLE api_keys ADD COLUMN public_identifier VARCHAR(8);

ALTER TABLE project_channel ADD COLUMN configuration_json JSONB;

ALTER TABLE project_channel
    ALTER COLUMN configuration_json
        SET DEFAULT '{}';

UPDATE project_channel
SET configuration_json = '{}'
WHERE configuration_json IS NULL;

ALTER TABLE videos
    ADD COLUMN marked_to_process BOOLEAN DEFAULT FALSE;


/* ----------------------------------------------------------
   ASSUMPTIONS
   ----------------------------------------------------------
   • You already have:
       – TABLE users          (user_id  PK)
       – TABLE statuses       (status_id PK, rows 1‑4 = pending/processing/done/error)
       – FUNCTION update_updated_at_column()  -- the generic “touch updated_at” trigger
   • You want natural keys for channels (YouTube ID) and videos.
   • Timestamps are TIMESTAMPTZ for correct TZ handling.
   ----------------------------------------------------------*/


/* ==========================================================
   0.  Lookup: how a piece of content can be processed
   ==========================================================*/
-- DROP TABLE IF EXISTS rip_styles CASCADE;

CREATE TABLE rip_styles (
                            rip_style_id SMALLINT  GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                            name         VARCHAR(50) UNIQUE NOT NULL,
                            description  TEXT
);

CREATE TRIGGER update_rip_styles_updated_at
    BEFORE UPDATE ON rip_styles
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

/* Seed your two current workflows */
INSERT INTO rip_styles (name, description)
VALUES
    ('remix',     'Copy with small tweaks (thumbnail, intro, etc.)'),
    ('translate', 'Generate a translated/dubbed version in another language');


/* ==========================================================
   1.  Master list of external channels
   ==========================================================*/
-- DROP TABLE IF EXISTS channels CASCADE;

CREATE TABLE channels (
                          channel_id      VARCHAR(24) PRIMARY KEY,     -- e.g. UC_xxx…
                          platform        VARCHAR(50)  NOT NULL DEFAULT 'YouTube',

                          url             VARCHAR(255)         NOT NULL,
                          title           VARCHAR(100),
                          profile_pic     VARCHAR(255),

                          last_fetched_at TIMESTAMPTZ,                  -- global freshness marker
                          created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                          updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TRIGGER update_channels_updated_at
    BEFORE UPDATE ON channels
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();


/* ==========================================================
   2.  External videos (one row per YouTube video)
   ==========================================================*/
-- DROP TABLE IF EXISTS external_videos CASCADE;

CREATE TABLE external_videos (
                                 external_video_id         VARCHAR(11)  PRIMARY KEY,             -- natural key
                                 channel_id       VARCHAR(24) NOT NULL
                                     REFERENCES channels(channel_id),

                                 url              VARCHAR(255)         NOT NULL,
                                 title            VARCHAR(100),
                                 duration_seconds INTEGER,
                                 published_at     TIMESTAMPTZ,

                                 last_fetched_at  TIMESTAMPTZ,      -- stats/metadata refresh time
                                 created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                                 updated_at       TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_videos_channel_id
    ON external_videos(channel_id);

CREATE TRIGGER update_external_videos_updated_at
    BEFORE UPDATE ON external_videos
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();


/* ==========================================================
   3.  Per‑user per‑channel workflow state
   ==========================================================*/
-- DROP TABLE IF EXISTS user_channel_rips CASCADE;

CREATE TABLE user_channel_rips (
                                   user_id          INTEGER      NOT NULL REFERENCES users(user_id),
                                   channel_id       VARCHAR(24) NOT NULL REFERENCES channels(channel_id),
                                   rip_style_id     SMALLINT     NOT NULL REFERENCES rip_styles(rip_style_id),

                                   process BOOLEAN     NOT NULL DEFAULT FALSE,
                                   requested_at     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
                                   updated_at       TIMESTAMPTZ  NOT NULL DEFAULT NOW(),

                                   PRIMARY KEY (user_id, channel_id, rip_style_id)
);

CREATE TRIGGER update_user_channel_rips_updated_at
    BEFORE UPDATE ON user_channel_rips
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();


/* ==========================================================
   4.  Per‑user per‑video workflow state
   ==========================================================*/
-- DROP TABLE IF EXISTS user_video_rips CASCADE;

CREATE TABLE user_video_rips (
                                 user_id           INTEGER      NOT NULL REFERENCES users(user_id),
                                 external_video_id          VARCHAR(11)  NOT NULL REFERENCES external_videos(external_video_id)
                                     ON DELETE CASCADE,
                                 rip_style_id      SMALLINT     NOT NULL REFERENCES rip_styles(rip_style_id),

                                 process BOOLEAN      NOT NULL DEFAULT FALSE,
                                 requested_at      TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
                                 updated_at        TIMESTAMPTZ  NOT NULL DEFAULT NOW(),

                                 PRIMARY KEY (user_id, external_video_id, rip_style_id)
);

CREATE TRIGGER update_user_video_rips_updated_at
    BEFORE UPDATE ON user_video_rips
    FOR EACH ROW
    EXECUTE PROCEDURE update_updated_at_column();

/* ==========================================================
   Done – the schema now supports:
     • many users ↔︎ many channels ↔︎ many styles
     • many users ↔︎ many videos   ↔︎ many styles
     • independent status & “process” flags for each combo
   ==========================================================*/

-- 1. Add the language columns (NULL‑able by default)
ALTER TABLE user_channel_rips
    ADD COLUMN origin_language_id INTEGER,
    ADD COLUMN target_language_id INTEGER;

-- 2. Add the foreign‑key constraints with ON DELETE behaviour
ALTER TABLE user_channel_rips
    ADD CONSTRAINT user_channel_rips_origin_language_fkey
        FOREIGN KEY (origin_language_id)
            REFERENCES languages(id)
            ON DELETE SET NULL,
    ADD CONSTRAINT user_channel_rips_target_language_fkey
        FOREIGN KEY (target_language_id)
            REFERENCES languages(id)
            ON DELETE SET NULL;


CREATE UNIQUE INDEX user_channel_rips_lang_unique
    ON user_channel_rips (user_id,
                          channel_id,
                          rip_style_id,
                          origin_language_id,
                          target_language_id);

/* 1. Add the columns — NULL‑able by default */
ALTER TABLE user_video_rips
    ADD COLUMN origin_language_id INTEGER,
    ADD COLUMN target_language_id INTEGER;

/* 2. Foreign‑key constraints with ON DELETE SET NULL */
ALTER TABLE user_video_rips
    ADD CONSTRAINT user_video_rips_origin_language_fkey
        FOREIGN KEY (origin_language_id)
            REFERENCES languages(id)
            ON DELETE SET NULL,
    ADD CONSTRAINT user_video_rips_target_language_fkey
        FOREIGN KEY (target_language_id)
            REFERENCES languages(id)
            ON DELETE SET NULL;

/* 3. Uniqueness rule that kicks in only when languages are present */
CREATE UNIQUE INDEX user_video_rips_lang_unique
    ON user_video_rips (user_id,
                        external_video_id,
                        rip_style_id,
                        origin_language_id,
                        target_language_id);

-- 1. Add the new processed column (defaulting to FALSE)
ALTER TABLE user_video_rips
    ADD COLUMN processed BOOLEAN NOT NULL DEFAULT FALSE;

-- 2b. (Recommended) A *partial* index for faster “unprocessed” lookups
CREATE INDEX idx_user_video_rips_unprocessed
    ON user_video_rips(external_video_id, rip_style_id)
    WHERE processed = FALSE;

-- Add per-user seat limit
ALTER TABLE users
    ADD COLUMN license_limit INTEGER NOT NULL DEFAULT 0;

-- Extend api_keys to track active flag and device binding
ALTER TABLE api_keys
    ADD COLUMN is_active         BOOLEAN         NOT NULL DEFAULT TRUE,
    ADD COLUMN device_id        UUID,
    ADD COLUMN device_registered TIMESTAMPTZ;

-- Ensure each key binds to at most one device (partial unique index)
CREATE UNIQUE INDEX single_device_per_key
    ON api_keys(api_key_id, device_id)
    WHERE device_id IS NOT NULL;

CREATE TABLE logs (
                      id        BIGSERIAL      PRIMARY KEY,
                      ts        TIMESTAMPTZ    NOT NULL DEFAULT now(),
                      user_id   INTEGER                   NOT NULL
                          REFERENCES users(user_id)
                              ON UPDATE CASCADE
                              ON DELETE RESTRICT,
                      level     TEXT           NOT NULL,
                      message   JSONB          NOT NULL
);

-- 3) Indexes for fast querying
CREATE INDEX idx_logs_ts_desc
    ON logs (ts DESC);

CREATE INDEX idx_logs_user_ts_desc
    ON logs (user_id, ts DESC);

CREATE INDEX idx_logs_message_gin
    ON logs
        USING GIN (message);

CREATE TABLE discord_generations (
                                     generation_id    INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                     username         CITEXT        NOT NULL,
                                     generation_type  CITEXT        NOT NULL,  -- now case-insensitive too
                                     message          TEXT          NOT NULL,
                                     created_at       TIMESTAMPTZ   NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_discord_generations_username
    ON discord_generations(username);

CREATE INDEX idx_discord_generations_type
    ON discord_generations(generation_type);

/* ==========================================================
   Script-profile history
   ----------------------------------------------------------
   • One row per version of a user’s “script profile”
   • FK links: users ▸ project_channel ▸ statuses
   ==========================================================*/

-- 1. Table
CREATE TABLE script_profile_history (
                                        script_profile_history_id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                        user_id        INTEGER      NOT NULL,
                                        channel_id     INTEGER      NOT NULL,
                                        title          VARCHAR(255) NOT NULL,
                                        json_text      JSONB        NOT NULL,
                                        status_id      SMALLINT     NOT NULL,
                                        created_at     TIMESTAMPTZ  NOT NULL DEFAULT NOW(),

                                        FOREIGN KEY (user_id)    REFERENCES users(user_id),
                                        FOREIGN KEY (channel_id) REFERENCES project_channel(channel_id),
                                        FOREIGN KEY (status_id)  REFERENCES statuses(status_id)
);

-- 2. Helpful indexes on the FKs
CREATE INDEX idx_script_profile_history_user_id
    ON script_profile_history(user_id);

CREATE INDEX idx_script_profile_history_channel_id
    ON script_profile_history(channel_id);

CREATE INDEX idx_script_profile_history_status_id
    ON script_profile_history(status_id);


/* ==========================================================
   1.  Lookup table – third-party services
   ==========================================================*/
CREATE TABLE services (
                          service_id  SMALLINT     GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                          name        VARCHAR(100)  NOT NULL UNIQUE,
                          description TEXT
);

-- Seed: first service = “Minimax”
INSERT INTO services (service_id, name, description)
    OVERRIDING SYSTEM VALUE
VALUES (1, 'Minimax', 'Minimax external AI service');

/* ==========================================================
   2.  Per-user API keys for those services
   ==========================================================*/
CREATE TABLE service_api_keys (
                                  service_api_key_id INTEGER      GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
                                  user_id     INTEGER      NOT NULL,
                                  service_id  SMALLINT     NOT NULL,
                                  api_key     TEXT         NOT NULL,
                                  display_name VARCHAR(255),

                                  created_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
                                  updated_at  TIMESTAMPTZ  NOT NULL DEFAULT NOW(),

                                  FOREIGN KEY (user_id)    REFERENCES users(user_id),
                                  FOREIGN KEY (service_id) REFERENCES services(service_id)
);

-- Helpful FK indexes
CREATE INDEX idx_service_api_keys_user_id
    ON service_api_keys(user_id);

CREATE INDEX idx_service_api_keys_service_id
    ON service_api_keys(service_id);

-- auto-touch updated_at
CREATE TRIGGER update_service_api_keys_updated_at
    BEFORE UPDATE ON service_api_keys
    FOR EACH ROW
EXECUTE PROCEDURE update_updated_at_column();

ALTER TABLE service_api_keys
    ADD COLUMN minimax_group_id VARCHAR(255);

CREATE TABLE background_tasks (
                                  task_id              SERIAL PRIMARY KEY,
                                  queue_id             INTEGER     NOT NULL REFERENCES queue(queue_id),
                                  task_type            VARCHAR(100) NOT NULL,
                                  data                 JSONB        NOT NULL,

                                  status_id            SMALLINT     NOT NULL DEFAULT 1
                                      REFERENCES statuses(status_id),

                                  attempts             INT          NOT NULL DEFAULT 0,
                                  created_at           TIMESTAMPTZ  NOT NULL DEFAULT (NOW() AT TIME ZONE 'UTC'),
                                  updated_at           TIMESTAMPTZ  NOT NULL DEFAULT NOW(),          -- ★ NEW
                                  last_attempted_at    TIMESTAMPTZ,
                                  completed_at         TIMESTAMPTZ,
                                  error_message        TEXT,
                                  lock_id              UUID,
                                  lock_acquired_at     TIMESTAMPTZ,
                                  locked_by_worker_id  VARCHAR(255)
);

-- Auto-touch updated_at on UPDATE
CREATE TRIGGER update_background_tasks_updated_at
    BEFORE UPDATE ON background_tasks
    FOR EACH ROW
EXECUTE PROCEDURE update_updated_at_column();

INSERT INTO asset_types (name, description) VALUES ('sequence_image', 'Sequence images');
INSERT INTO asset_types (name, description) VALUES ('sequence_video', 'Sequence video');

ALTER TABLE users
    ADD COLUMN is_elevate         BOOLEAN         NOT NULL DEFAULT FALSE;

ALTER TABLE users
    ADD COLUMN is_lifetime         BOOLEAN         NOT NULL DEFAULT FALSE;

ALTER TABLE suscriptions
    ADD COLUMN tokens INTEGER         NOT NULL DEFAULT 0;

INSERT INTO roles (role_id, name, description) VALUES(4, 'Basic', 'Basic sub');
INSERT INTO roles (role_id, name, description) VALUES(5, 'Pro', 'Pro sub');
INSERT INTO roles (role_id, name, description) VALUES(6, 'VIP', 'VIP sub');
INSERT INTO roles (role_id, name, description) VALUES(7, 'Lifetime', 'Lifetime');

------------------------------------- SUBS NORMALES -------------------------------------

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Basic', 'Basic Sub', 1.00, true, 0, false, 'prod_SMg1Pql6hgr2Yf');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Mid', 'Mid Sub', 2.00, true, 0, false, 'prod_SMg1Pql6hgr2Yf');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Premium', 'Premium Sub', 4.00, true, 0, false, 'prod_SMg1Pql6hgr2Yf');

-----------------------------------------------------------------------------------------

------------------------------------- SUBS ELEVATE -------------------------------------

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Elevate Premium Sub', 'Elevate Premium Sub', 4.00, true, 0, false, 'prod_SMg1Pql6hgr2Yf');

-----------------------------------------------------------------------------------------

------------------------------------- REFILLS -------------------------------------
-- TIERS --
INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Basic Refill', 'Basic Refill', 1.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Mid Refill', 'Mid Refill', 2.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Premium Refill', 'Premium Refill', 4.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');
-----------

-- Elevate --
INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Elevate Premium Refill', 'Elevate Premium Refill', 4.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');

INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Elevate Premium Refill', 'Elevate Premium Refill', 4.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');
-----------

-- Lifetime --
INSERT INTO suscriptions (name, description, price, active, show_order, is_one_time, product_id)
VALUES ('Lifetime Refill', 'Lifetime Refill', 4.00, true, 0, true, 'prod_SMg1Pql6hgr2Yf');
-----------

-- Add Rewardful/affiliate tracking columns to users
ALTER TABLE users
    ADD COLUMN affiliate_id            VARCHAR(50),          -- Rewardful affiliate ID
    ADD COLUMN rewardful_referral_id   VARCHAR(50),          -- Visitor-level UUID from Rewardful
    ADD COLUMN referral_captured_at    TIMESTAMP;            -- First time we stored the referral ID

CREATE TABLE DataProtectionKeys (
                                    Id SERIAL PRIMARY KEY,
                                    FriendlyName TEXT NULL,
                                    Xml TEXT NULL
);

-- 1) Create (or replace) the trigger function
CREATE OR REPLACE FUNCTION trg_user_role_change()
    RETURNS TRIGGER
    LANGUAGE plpgsql
AS $$
BEGIN
    -- Only act if role_id truly changed
    IF NEW.role_id IS DISTINCT FROM OLD.role_id THEN

        -- Case: upgrading to VIP (6) or Lifetime (7)
        IF NEW.role_id IN (6, 7) THEN
            -- only bump if below 2
            IF NEW.license_limit < 2 THEN
                NEW.license_limit := 2;
            END IF;

            -- Case: any other role
        ELSE
            -- remove all seats
            NEW.license_limit := 0;

            -- and clear device binding on all that user's API keys
            UPDATE api_keys
            SET device_id        = NULL
              , device_registered = NULL
            WHERE user_id = NEW.user_id;
        END IF;

    END IF;

    RETURN NEW;
END;
$$;

-- 2) Attach it as a BEFORE UPDATE trigger on users
DROP TRIGGER IF EXISTS user_role_change ON users;
CREATE TRIGGER user_role_change
    BEFORE UPDATE
    ON users
    FOR EACH ROW
    WHEN (OLD.role_id IS DISTINCT FROM NEW.role_id)
EXECUTE PROCEDURE trg_user_role_change();

/* ----------------------------------------------------------
   Discord integration – store both fields as plain text
   ----------------------------------------------------------*/
BEGIN;

-- 1) Add the columns (nullable while you back-fill)
ALTER TABLE users
    ADD COLUMN discord_id   VARCHAR(64),   -- ID as a string (Snowflake or other)
    ADD COLUMN discord_name VARCHAR(100);  -- e.g. "MyUser#1234"

-- 2) One Discord account → one user
CREATE UNIQUE INDEX IF NOT EXISTS users_discord_id_unique
    ON users(discord_id)
    WHERE discord_id IS NOT NULL;

-- 3) Handy look-up on nickname (case-insensitive)
CREATE INDEX IF NOT EXISTS idx_users_discord_name_ci
    ON users (lower(discord_name));

COMMIT;

